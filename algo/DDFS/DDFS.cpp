//
// Created by Thoh Testarossa on 2019-08-22.
//

#include "DDFS.h"

#include <iostream>
#include <ctime>

template<typename VertexValueType>
DDFS<VertexValueType>::DDFS()
{

}

template<typename VertexValueType>
void DDFS<VertexValueType>::MSGApply(Graph<VertexValueType> &g, const std::vector<int> &initVSet,
                                     std::set<int> &activeVertice, const MessageSet<VertexValueType> &mSet)
{
    //Activity reset
    activeVertice.clear();

    //Availability check
    if(g.vCount <= 0) return;

    //array form computation
    this->MSGApply_array(g.vCount, g.eCount, &g.vList[0], this->numOfInitV, &initVSet[0], &g.verticesValue[0], &mSet.mSet[0]);

    //Active vertices set assembly
    for(int i = 0; i < g.vCount; i++)
    {
        if(g.vList.at(i).isActive)
            activeVertice.insert(i);
    }
}

template<typename VertexValueType>
void DDFS<VertexValueType>::MSGGenMerge(const Graph<VertexValueType> &g, const std::vector<int> &initVSet,
                                        const std::set<int> &activeVertice, MessageSet<VertexValueType> &mSet)
{
    //Generate merged msgs directly

    //Availability check
    if(g.vCount <= 0) return;

    //array form computation
    this->MSGGenMerge_array(g.vCount, g.eCount, &g.vList[0], &g.eList[0], this->numOfInitV, &initVSet[0], &g.verticesValue[0], &mSet.mSet[0]);
}

template<typename VertexValueType>
void DDFS<VertexValueType>::MSGApply_array(int vCount, int eCount, Vertex *vSet, int numOfInitV, const int *initVSet,
                                           VertexValueType *vValues, VertexValueType *mValues)
{
    //Reset vertex activity
    for(int i = 0; i < vCount; i++)
        vSet[i].isActive = false;

    //Reset msgs mark
    for(int i = 0; i < vCount; i++)
    {
        for(auto &vState : vValues[i].vStateList)
            vState.second &= MSG_SEND_RESET;
    }

    //Check each msgs
    for(int i = 0; i < vCount; i++)
    {
        for(int j = 0; j < mValues[i].relatedVCount; j++)
        {
            int srcVID = i, dstVID = mValues[i].vStateList[j].first;
            //Processing token message
            if(mValues[i].vStateList[j].second & MSG_SEND_TOKEN)
            {
                if(vValues[i].state == STATE_IDLE)
                {
                    vValues[i].state == STATE_DISCOVERED;
                    //mark j as i's father
                    vValues[i].parentIndex = j;
                    vValues[i].vStateList[j].second |= MARK_PARENT;

                    this->search(i, numOfInitV, initVSet, vSet, vValues);
                    for(auto &vState : vValues[i].vStateList)
                        vState.second |= MSG_SEND_VISITED;
                    //Vertex which will send msg will be activated
                    vSet[i].isActive = true;
                }
                else
                {
                    if(!(vValues[i].vStateList[j].second & MARK_VISITED))
                        vValues[i].vStateList[j].second |= MARK_VISITED;
                    if(vValues[i].vStateList[j].second & MARK_SON)
                        this->search(i, numOfInitV, initVSet, vSet, vValues);
                }
            }
            //Processing visited message
            if(mValues[i].vStateList[j].second & MSG_SEND_VISITED)
            {
                if(!(vValues[i].vStateList[j].second & MARK_VISITED))
                    vValues[i].vStateList[j].second |= MARK_VISITED;
                if(vValues[i].vStateList[j].second & MARK_SON)
                {
                    vValues[i].vStateList[j].second |= MARK_VISITED;
                    this->search(i, numOfInitV, initVSet, vSet, vValues);
                }
            }
        }
    }
}

template<typename VertexValueType>
void
DDFS<VertexValueType>::MSGGenMerge_array(int vCount, int eCount, const Vertex *vSet, const Edge *eSet, int numOfInitV,
                                         const int *initVSet, const VertexValueType *vValues, VertexValueType *mValues)
{
    //Reset msgs mark
    for(int i = 0; i < vCount; i++)
    {
        for(auto &m_v : mValues[i].vStateList)
            m_v.second &= MSG_SEND_RESET;
    }

    //Generate msgs from vState generated by previous iteration
    for(int i = 0; i < vCount; i++)
    {
        //Vertex which wants to send msgs must be active
        if(vSet[i].isActive)
        {
            for(int j = 0; j < vValues[i].relatedVCount; j++)
            {
                if(vValues[i].vStateList[j].second & MSG_SEND_TOKEN)
                    mValues[i].vStateList[j].second |= MSG_SEND_TOKEN;
                if(vValues[i].vStateList[j].second & MSG_SEND_VISITED)
                    mValues[i].vStateList[j].second |= MSG_SEND_VISITED;
            }
        }
    }
}

template<typename VertexValueType>
void DDFS<VertexValueType>::MergeGraph(Graph<VertexValueType> &g, const std::vector<Graph<VertexValueType>> &subGSet,
                                       std::set<int> &activeVertices,
                                       const std::vector<std::set<int>> &activeVerticeSet,
                                       const std::vector<int> &initVList)
{

}

template<typename VertexValueType>
void DDFS<VertexValueType>::Init(int vCount, int eCount, int numOfInitV)
{

}

template<typename VertexValueType>
void DDFS<VertexValueType>::GraphInit(Graph<VertexValueType> &g, std::set<int> &activeVertices,
                                      const std::vector<int> &initVList)
{
    //Graph data framework init

    //Starter init
    int start = initVList[0];
    g.verticesValue.at(start).state = true;
    this->search(start, numOfInitV, &initVList[0], &g.vList[0], &g.verticesValue[0]);
    for(auto &vState : g.verticesValue.at(start).vStateList)
        vState.second |= MSG_SEND_VISITED;
    g.vList.at(start).isActive = true;

}

template<typename VertexValueType>
void DDFS<VertexValueType>::Deploy(int vCount, int eCount, int numOfInitV)
{

}

template<typename VertexValueType>
void DDFS<VertexValueType>::Free()
{

}

template<typename VertexValueType>
int DDFS<VertexValueType>::search(int vid, int numOfInitV, const int *initVSet, Vertex *vSet, VertexValueType *vValues)
{
    bool chk = false;
    for(auto &vState : vValues[vid].vStateList)
    {
        if(!(vState.second & MARK_VISITED))
        {
            chk = true;
            vState.second |= MARK_VISITED;
            vState.second |= MSG_SEND_TOKEN;
            //Vertex which will send msg will be activated
            vSet[vid].isActive = true;
        }
    }

    if(!chk)
    {
        if(vid == initVSet[0]) return -1;
        else
            vValues[vid].vStateList[vValues[vid].parentIndex].second |= MSG_SEND_TOKEN;
    }

    return 0;
}

